<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!--Converted with LaTeX2HTML 96.1-c (Feb 29, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<title>6.2.2 Creating Pipes in C</title>
<meta name="description" content="6.2.2 Creating Pipes in C">
<meta name="keywords" content="lpg">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<link rel="STYLESHEET" href="6.2.2%20Creating%20Pipes%20in%20C_files/lpg.css">
</head>
<body lang="EN">
 <a name="tex2html468" href="https://tldp.org/LDP/lpg/node12.html"><img alt="next" src="6.2.2%20Creating%20Pipes%20in%20C_files/next_motif.gif" width="37" height="24" align="BOTTOM"></a> <a name="tex2html466" href="https://tldp.org/LDP/lpg/node9.html"><img alt="up" src="6.2.2%20Creating%20Pipes%20in%20C_files/up_motif.gif" width="26" height="24" align="BOTTOM"></a> <a name="tex2html460" href="https://tldp.org/LDP/lpg/node10.html"><img alt="previous" src="6.2.2%20Creating%20Pipes%20in%20C_files/previous_motif.gif" width="63" height="24" align="BOTTOM"></a> <a name="tex2html470" href="https://tldp.org/LDP/lpg/node1.html"><img alt="contents" src="6.2.2%20Creating%20Pipes%20in%20C_files/contents_motif.gif" width="65" height="24" align="BOTTOM"></a>  <br>
<b> Next:</b> <a name="tex2html469" href="https://tldp.org/LDP/lpg/node12.html">6.2.3 Pipes the Easy </a>
<b>Up:</b> <a name="tex2html467" href="https://tldp.org/LDP/lpg/node9.html">6.2 Half-duplex UNIX Pipes</a>
<b> Previous:</b> <a name="tex2html461" href="https://tldp.org/LDP/lpg/node10.html">6.2.1 Basic Concepts</a>
<br> <p>
</p><h2><a name="SECTION00722000000000000000">6.2.2 Creating Pipes in C</a></h2>
<p>
Creating ``pipelines'' with the C programming language can be a bit more involved
than our simple shell example.  To create a simple pipe with C, we make use of
the pipe() system call.  It takes a single argument, which is an array of two
integers, and if successful, the array will contain two new file descriptors
to be used for the pipeline. After creating a pipe, the process typically
spawns a new process (remember the child inherits open file descriptors).
</p><p>
</p><p>
</p><hr><pre>  SYSTEM CALL: pipe();                                                          

  PROTOTYPE: int pipe( int fd[2] );                                             
    RETURNS: 0 on success                                                       
             -1 on error: errno = EMFILE (no free descriptors)                  
                                  EMFILE (system file table is full)            
                                  EFAULT (fd array is not valid)                

  NOTES: fd[0] is set up for reading, fd[1] is set up for writing</pre> 
<hr>The first integer in the array (element 0) is set up and opened for reading,
while the second integer (element 1) is set up and opened for writing.  
Visually speaking, the output of fd1 becomes the input for fd0.  Once
again, all data traveling through the pipe moves through the kernel.
<p>
</p><pre>        #include &lt;stdio.h&gt;
        #include &lt;unistd.h&gt;
        #include &lt;sys/types.h&gt;

        main()
        {
                int     fd[2];
                
                pipe(fd);
                .
                .
        }</pre>
<p>
Remember that an array name in C <em>decays</em> into a pointer to its first
member.  Above, <tt>fd</tt> is equivalent to <tt>&amp;fd[0]</tt>.  Once we have established the
pipeline, we then fork our new child process:
</p><p>
</p><pre>        #include &lt;stdio.h&gt;
        #include &lt;unistd.h&gt;
        #include &lt;sys/types.h&gt;

        main()
        {
                int     fd[2];
                pid_t   childpid;

                pipe(fd);
        
                if((childpid = fork()) == -1)
                {
                        perror("fork");
                        exit(1);
                }
                .
                .
        }</pre>
<p>
If the parent wants to receive data from the child, it should close fd1,
and the child should close fd0. If the parent wants to send data to the
child, it should close fd0, and the child should close fd1. Since
descriptors are shared between the parent and child, we should always be sure
to close the end of pipe we aren't concerned with.  On a technical note, the
EOF will never be returned if the unnecessary ends of the pipe are not
explicitly closed.
</p><p>
</p><pre>        #include &lt;stdio.h&gt;
        #include &lt;unistd.h&gt;
        #include &lt;sys/types.h&gt;

        main()
        {
                int     fd[2];
                pid_t   childpid;

                pipe(fd);
        
                if((childpid = fork()) == -1)
                {
                        perror("fork");
                        exit(1);
                }

                if(childpid == 0)
                {
                        /* Child process closes up input side of pipe */
                        close(fd[0]);
                }
                else
                {
                        /* Parent process closes up output side of pipe */
                        close(fd[1]);
                }
                .
                .
        }</pre>
<p>
As mentioned previously, once the pipeline has been established, the file
descriptors may be treated like descriptors to normal files.
</p><p>
</p><pre>/*****************************************************************************
 Excerpt from "Linux Programmer's Guide - Chapter 6"
 (C)opyright 1994-1995, Scott Burkett
 ***************************************************************************** 
 MODULE: pipe.c
 *****************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;

int main(void)
{
        int     fd[2], nbytes;
        pid_t   childpid;
        char    string[] = "Hello, world!\n";
        char    readbuffer[80];

        pipe(fd);
        
        if((childpid = fork()) == -1)
        {
                perror("fork");
                exit(1);
        }

        if(childpid == 0)
        {
                /* Child process closes up input side of pipe */
                close(fd[0]);

                /* Send "string" through the output side of pipe */
                write(fd[1], string, (strlen(string)+1));
                exit(0);
        }
        else
        {
                /* Parent process closes up output side of pipe */
                close(fd[1]);

                /* Read in a string from the pipe */
                nbytes = read(fd[0], readbuffer, sizeof(readbuffer));
                printf("Received string: %s", readbuffer);
        }
        
        return(0);
}</pre>
<p>
Often, the descriptors in the child are duplicated onto standard input 
or output.  The child can then exec() another program, which inherits the
standard streams.  Let's look at the dup() system call:
</p><p>
</p><p>
</p><hr><pre>  SYSTEM CALL: dup();                                                           

  PROTOTYPE: int dup( int oldfd );                                              
    RETURNS: new descriptor on success                                          
             -1 on error: errno = EBADF (oldfd is not a valid descriptor)       
                                  EBADF (newfd is out of range)                 
                                  EMFILE (too many descriptors for the process) 

  NOTES: the old descriptor is not closed!  Both may be used interchangeably</pre> 
<hr>Although the old descriptor and the newly created descriptor can be used
interchangeably, we will typically close one of the standard streams first.
The dup() system call uses the lowest-numbered, unused descriptor for the
new one.
<p>
Consider:
</p><p>
</p><pre>        .
        .
        childpid = fork();
        
        if(childpid == 0)
        {
                /* Close up standard input of the child */
                close(0);
                
                /* Duplicate the input side of pipe to stdin */
                dup(fd[0]);
                execlp("sort", "sort", NULL);
                .
        }</pre>
<p>
Since file descriptor 0 (stdin) was closed, the call to dup() duplicated the 
input descriptor of the pipe (fd0) onto its standard input.  We then make
a call to execlp(), to overlay the child's text segment (code) with that of
the sort program.  Since newly exec'd programs inherit standard streams from
their spawners, it actually inherits the input side of the pipe as its
standard input!  Now, anything that the original parent process sends to the
pipe, goes into the sort facility.
</p><p>
There is another system call, dup2(), which can be used as well.  This 
particular call originated with Version 7 of UNIX, and was carried on through
the BSD releases and is now required by the POSIX standard.
</p><p>
</p><p>
</p><hr><pre>  SYSTEM CALL: dup2();                                                          

  PROTOTYPE: int dup2( int oldfd, int newfd );                                  
    RETURNS: new descriptor on success                                          
             -1 on error: errno = EBADF (oldfd is not a valid descriptor)       
                                  EBADF (newfd is out of range)                 
                                  EMFILE (too many descriptors for the process) 

  NOTES: the old descriptor is closed with dup2()!</pre> 
<hr>With this particular call, we have the close operation, and the actual
descriptor duplication, wrapped up in one system call.  In addition, it
is guaranteed to be atomic, which essentially means that it will never
be interrupted by an arriving signal.  The entire operation will transpire
before returning control to the kernel for signal dispatching.  With the
original dup() system call, programmers had to perform a close() operation
before calling it.  That resulted in two system calls, with a small degree
of vulnerability in the brief amount of time which elapsed between them.  
If a signal arrived during that brief instance, the descriptor duplication
would fail.  Of course, dup2() solves this problem for us.
<p>
Consider:
</p><p>
</p><pre>        .
        .
        childpid = fork();
        
        if(childpid == 0)
        {
                /* Close stdin, duplicate the input side of pipe to stdin */
                dup2(0, fd[0]);
                execlp("sort", "sort", NULL);
                .
                .
        }</pre>
<p>
</p><hr><a name="tex2html468" href="https://tldp.org/LDP/lpg/node12.html"><img alt="next" src="6.2.2%20Creating%20Pipes%20in%20C_files/next_motif.gif" width="37" height="24" align="BOTTOM"></a> <a name="tex2html466" href="https://tldp.org/LDP/lpg/node9.html"><img alt="up" src="6.2.2%20Creating%20Pipes%20in%20C_files/up_motif.gif" width="26" height="24" align="BOTTOM"></a> <a name="tex2html460" href="https://tldp.org/LDP/lpg/node10.html"><img alt="previous" src="6.2.2%20Creating%20Pipes%20in%20C_files/previous_motif.gif" width="63" height="24" align="BOTTOM"></a> <a name="tex2html470" href="https://tldp.org/LDP/lpg/node1.html"><img alt="contents" src="6.2.2%20Creating%20Pipes%20in%20C_files/contents_motif.gif" width="65" height="24" align="BOTTOM"></a>  <br>
<b> Next:</b> <a name="tex2html469" href="https://tldp.org/LDP/lpg/node12.html">6.2.3 Pipes the Easy </a>
<b>Up:</b> <a name="tex2html467" href="https://tldp.org/LDP/lpg/node9.html">6.2 Half-duplex UNIX Pipes</a>
<b> Previous:</b> <a name="tex2html461" href="https://tldp.org/LDP/lpg/node10.html">6.2.1 Basic Concepts</a>
<p></p><address>
<i>Converted on: <br>
Fri Mar 29 14:43:04 EST 1996</i>
</address>


</body></html>